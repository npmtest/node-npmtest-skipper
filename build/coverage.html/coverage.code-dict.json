{"/home/travis/build/npmtest/node-npmtest-skipper/test.js":"/* istanbul instrument in package npmtest_skipper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-skipper/lib.npmtest_skipper.js":"/* istanbul instrument in package npmtest_skipper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_skipper = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_skipper = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-skipper/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-skipper && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_skipper */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_skipper\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_skipper.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_skipper.rollup.js'] =\n            local.assetsDict['/assets.npmtest_skipper.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_skipper.__dirname + '/lib.npmtest_skipper.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/index.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar toParseMultipartHTTPRequest = require('./lib/multipart');\nvar bodyParser = require('body-parser');\nvar Upstream = require('./standalone/Upstream');\n\n// Double-check that a valid Node version with support for streams2\n// is being used\nif (!require('semver').satisfies(process.version, '>=0.10.0')) {\n  console.error('`skipper` (bodyParser) requires node version >= 0.10.0.');\n  console.error('Please upgrade Node at http://nodejs.org/ or with `nvm`');\n  throw new Error('Invalid Node.js version');\n}\n\n/**\n * Skipper\n *\n * @param  {Object} options [description]\n * @return {Function}\n */\n\nmodule.exports = function toParseHTTPBody(options) {\n  options = options || {};\n\n  // Configure body parser components\n\n  // For URLEncoded, default the \"extended\" option to true for backwards compatibility,\n  // and to avoid a deprecation warning (see https://github.com/expressjs/body-parser#options-3)\n  // Also default request limit for JSON and URL-encoded parsers to 1mb for backwards compatibility.\n  var URLEncodedBodyParser = bodyParser.urlencoded(_.extend({extended: true, limit: '1mb'}, options));\n  var JSONBodyParser = bodyParser.json(_.extend({limit: '1mb'}, options));\n  var MultipartBodyParser = toParseMultipartHTTPRequest(options);\n\n\n  /**\n   * Connet/Express/Sails-compatible middleware.\n   *\n   * @param  {Request}   req  [description]\n   * @param  {Response}   res  [description]\n   * @param  {Function} next [description]\n   */\n\n  return function _parseHTTPBody(req, res, next) {\n\n    // If there's no `req.is`, bail out early because we won't be able to tell\n    // with certainty what the content-type is or isn't.\n    if (!req.is) {\n      return next(new Error('Consistency violation: `req.is` is not defined.\\n' +\n                            'This typically means that you are using an outdated version of Express.\\n'+\n                            'Skipper requires Express 3 or above.\\n'));\n    }\n\n    // Use custom body parser error handler if provided, otherwise\n    // just forward the error to the next Express error-handling middleware.\n    var handleError = function (err) {\n      if (options.onBodyParserError) {\n        return options.onBodyParserError(err, req, res, next);\n      }\n      return next(err);\n    };\n\n    // Optimization: skip bodyParser for GET, OPTIONS, or body-less requests.\n    if (req.method.toLowerCase() === 'get' || req.method.toLowerCase() === 'options' || req.method.toLowerCase() === 'head') {\n\n      // But stub out a `req.file()` method with a usage error:\n      req.file = function() {\n        throw new Error('`req.file()` cannot be used with an HTTP GET, OPTIONS, or HEAD request.');\n      };\n\n      return next();\n    }\n\n    // TODO: Optimization: only run bodyParser if this is a known route\n\n    // log.verbose('Running request ('+req.method+' ' + req.url + ') through bodyParser...');\n\n    // Mock up a req.file handler that returns a noop upstream, so that user code\n    // can use `req.file` without having to check for it first.  This is useful in cases\n    // where there may or may not be file params coming in.  The Multipart parser will\n    // replace this with an actual upstream-acquiring function if the request isn't successfully\n    // handled by one of the other parsers first.\n    req.file = function(fieldName) {\n      var noopUpstream = new Upstream({\n        noop: true\n      });\n      noopUpstream.fieldName = 'NOOP_'+fieldName;\n      return noopUpstream;\n    };\n\n    if (\n      // If we have a content-length header...\n      !_.isUndefined(req.headers['content-length']) &&\n      // And the content length is declared to be zero...\n      (req.headers['content-length'] === 0 || req.headers['content-length'] === '0')) {\n      // Then we set the body to any empty object\n      // and skip all this body-parsing mishegoss.\n      req.body = {};\n      return next();\n    }\n\n    // Try to parse a request that has application/json content type\n    JSONBodyParser(req, res, function(err) {\n      if (err) return handleError(err);\n      // If the parser actually ran and did some parsing, then we're done.\n      if (req.is('application/json')) {return next();}\n      // Otherwise try the URL-encoded parser (application/x-www-form-urlencoded type)\n      URLEncodedBodyParser(req, res, function(err) {\n        if (err) return handleError(err);\n        // If the parser actually ran and did some parsing, then we're done.\n        if (req.is('application/x-www-form-urlencoded')) {return next();}\n        // Otherwise try the multipart parser\n        MultipartBodyParser(req, res, function(err) {\n          if (err) return handleError(err);\n          // If the parser actually ran and did some parsing, then we're done.\n          if (req.is('multipart/form-data')) return next();\n\n          /**\n           * OK, here's how the re-run of the JSON bodyparser works:\n           * ========================================================\n           * If the original pass of the bodyParser failed to parse anything, rerun it,\n           * but with an artificial `application/json` content-type header,\n           * forcing it to try and parse the request body as JSON.  This is just in case\n           * the user sent a JSON request body, but forgot to set the appropriate header\n           * (which is pretty much every time, I think.)\n           */\n          var backupContentType = req.headers['content-type'];\n          req.headers['content-type'] = 'application/json';\n          JSONBodyParser(req, res, function(err) {\n\n            // Revert content-type to what it originally was.\n            // This is so we don't inadvertently corrupt `req.headers`--\n            // our apps' actions might be looking for 'em.\n            req.headers['content-type'] = backupContentType;\n\n            // If an error occurred in the retry, it's not actually an error\n            // (we can't assume EVERY requeset was intended to be JSON)\n            if (err) {\n              // log.verbose('Attempted to retry bodyParse as JSON.  But no luck.', err);\n            }\n\n            // Proceed, whether or not the body was parsed.\n            next();\n          });\n        });\n      });\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/multipart.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar log = require('../standalone/logger');\nvar Parser = require('./Parser');\n\n\n\n/**\n * Parse a multipart HTTP request.\n *\n * @param  {Object|nil} options\n * @return {Middleware}\n */\n\nmodule.exports = function toParseMultipartHTTPRequest(options) {\n  return function _parseMultipartHTTPRequest(req, res, next) {\n\n    //\n    // Conventions:\n    //  + Any other logic which mutates `req` should go in this file.\n    //  + Try not to pass direct access to `req` to other modules (violating this currently)\n    //  + Try not to pass direct access to `next` to other modules (violating this currently)\n    //\n\n    // If the content type is NOT explicitly set to \"multipart/form-data\",\n    // don't run all this expensive code -- just bail out early.\n    if (!req.is('multipart/form-data')) return next();\n\n    // Namespace a property on `req` and instantiate a Parser\n    // to put in there.\n    var parser = req._fileparser = new Parser(req, options, next);\n\n    // Expose `req.file(...)` method\n    req.file = _.bind(parser.acquireUpstream, parser);\n\n\n    // If parser emits `warning`, also emit it on `req` so it can be captured\n    // by your app.  When NODE_ENV != 'production', if `req._sails` exists, this\n    // will attempt to log a message to the console using your configured logger.\n    // If this doesn't work, it logs a message.  In production, no warnings are emitted.\n    if (process.env.NODE_ENV !== 'production') {\n      parser.on('warning', function(msg) {\n        if (req._sails) {\n          try {\n            req._sails.log.verbose(msg);\n          } catch (e) {}\n        } else log.color('yellow').write(msg);\n      });\n    }\n\n  };\n};\n\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/logger.js":"var _ = require('lodash');\n\n// todo rip this out (use the debug module)\n\n\n// (set to `true` to display development-only log messages)\nFILE_PARSER_LOGGER_ENABLED = (_.isString(process.env.DEBUG) && process.env.DEBUG.match('skipper'));\n\nvar logger;\nif (global.FILE_PARSER_LOGGER_ENABLED) {\n  require('colors');\n  logger = function consoleLogger( /* arg0, ..., argN */ ) {\n    console.log.apply(console, Array.prototype.slice.call(arguments));\n  };\n  logger.color = function colorLogger( color ) {\n    return {\n      write: function () {\n        console.log.apply(console,\n          _.reduce(Array.prototype.slice.call(arguments), function (m,v) {\n            try {\n              m.push(v[color]);\n            }\n            catch(e) { m.push(v); }\n            return m;\n          }, [])\n        );\n      }\n    };\n  };\n}\nelse {\n  logger = function noOp() {};\n  logger.color = function noOp() { return {write: function noOp(){}}; };\n}\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/index.js":"module.exports = require('./Parser');\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/Parser.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar applyDefaultOptions = require('./defaults');\n\n\n\n/**\n * Parser\n *\n * constructor\n *\n * @param {[type]} req     [description]\n * @param {[type]} options [description]\n * @param {Function} next\n */\n\nfunction Parser(req, options, next) {\n\n  this.req = req;\n  this.next = next;\n  this.options = options = applyDefaultOptions(options);\n\n  // Tracks Upstreams generated during this request.\n  this.upstreams = [];\n\n  // Tracks text params which have been received during this request.\n  // They may or may not have finished yet, as indicated by the `done`\n  // key on each object.  `stream` is the raw partstream from the multipart\n  // HTTP request.\n  this.textParams = [ /* {}, {} */ ];\n\n  this.parseReq();\n}\nutil.inherits(Parser, EventEmitter);\n\n\n/**\n * Parse an incoming multipart request.\n */\n\nParser.prototype.parseReq = require('./prototype.parseReq');\n\nParser.prototype.onFile = require('./prototype.onFile');\n\nParser.prototype.onTextParam = require('./prototype.onTextParam');\n\nParser.prototype.acquireUpstream = require('./prototype.acquireUpstream');\n\n\nmodule.exports = Parser;\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/defaults.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n\nmodule.exports = function(options) {\n\n  // Apply defaults\n  options = options || {};\n  _.defaults(options, {\n\n    // maxWaitTime is the maximum # of ms to wait for the first file\n    // if the request finishes before this number of ms (i.e. the form emits \"close\")\n    // then there is no problem.  Otherwise, a fatal ETIMEOUT error will fire.\n    maxTimeToWaitForFirstFile: 10000,\n\n    // maxBufferTime is the maximum # of ms to wait for an UploadStream\n    // to be plugged in to something (i.e. buffering the incoming bytes)\n    // before dropping it.\n    // (this can probably be replaced with `highWaterMark` and `lowWaterMark`\n    // in streams2)\n    maxTimeToBuffer: 4500,\n\n    // maxWaitTimeBeforePassingControlToApp is the maximum # of ms to wait for\n    // either a) a file to be encountered or b) the entire request body to be parsed,\n    // before turning control back over to the caller (e.g. a Sails controller).\n    // For SSL servers, it may be necessary to increase this value\n    // (see https://github.com/balderdashy/skipper/issues/71#issuecomment-217556631)\n    maxWaitTimeBeforePassingControlToApp: 500\n\n  });\n\n  return options;\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/prototype.parseReq.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar async = require('async');\nvar Form = require('multiparty').Form;\nvar log = require('../../standalone/logger');\nvar STRINGFILE = require('../../stringfile');\nvar debug = require('debug')('skipper');\n\n\n/**\n * Begin parsing an incoming HTTP request (`this.req`).\n */\n\nmodule.exports = function parseReq() {\n  var self = this;\n\n\n  // Save reference to `form` instance.\n  var form = this.form = new Form();\n\n\n\n  // Only one 'error' event should ever be emitted, and if an 'error' event\n  // is emitted, then 'close' should NOT be emitted.\n  form.on('error', function(err) {\n\n    debug('multiparty form emitted error:',err);\n\n    // Emits error on any already-live Upstreams in this request.\n    _.each(self.upstreams, function(up) {\n      up.fatalIncomingError(err);\n    });\n\n    // Flag Parser instance with an error\n    self._multipartyError = err||true;\n\n    // // Stop accepting form stuff.\n    // // (no more new incoming files/textparams)\n    // self.closed = true;\n\n    // // // Informs all Upstreams in this request\n    // // // that no more files will be sent.\n    // // _(self.upstreams).each(function(up) {\n    // //   up.noMoreFiles();\n  });\n\n\n  /**\n   * Receive/handle a new `part` stream from a field in the multipart upload.\n   * @param  {stream.Readable} part\n   */\n  form.on('part', _.bind(function(part) {\n\n    // In multiparty 4.x, parts can emit errors.\n    // So if that happens, we take that error and emit it on the form itself.\n    part.on('error', function(err){\n      form.emit(err||new Error('Multiparty part stream emitted an unexpected error, but no other information about it was available.'));\n    });\n\n    // Take care of text parameters (i.e. non-files)\n    if (!part.filename) {\n      this.onTextParam(part);\n      return;\n    }\n\n    // Custom handler for fields w/ files\n    this.onFile(part);\n  }, this));\n\n\n\n  // Emitted after all parts have been parsed and emitted. Not emitted if an\n  // `error` event is emitted.\n  form.on('close', function() {\n    log((STRINGFILE.get('parser.form.onClose')).grey);\n    debug('multiparty form closed.');\n\n    // Flag this request as closed\n    // (no more new incoming files/textparams)\n    self.closed = true;\n\n    // Informs all Upstreams in this request\n    // that no more files will be sent.\n    _.each(self.upstreams, function(up) {\n      up.noMoreFiles();\n    });\n\n    // Uncomment this (and comment out the `noMoreFiles` business above)\n    // to simulate an error for testing purposes:\n    // up.fatalIncomingError('whee');\n  });\n\n\n\n  // Set up 3 conditions under which this Parser will pass control\n  // to app-level code (i.e. call next())\n  // ONLY ONE of the following must be satisfied to continue onward.\n  // (careful! no error allowed in callbacks!)\n  var timer;\n  var whichGuard;\n  async.any([\n\n      // (1)\n      // As soon as request body has been completely parsed.\n      function requestBodyCompletelyParsed(done) {\n        form.once('close', function() {\n          if (!whichGuard){\n            debug('passed control to app because the request \"form\" closed (there probably weren\\'t any file uploads on this upstream)');\n            whichGuard = 'requestBodyCompletelyParsed';\n          }\n          done(true);\n        });\n      },\n\n      // (2)\n      // As soon as at least one file is received on any Upstream.\n      function receivedFirstFileOfRequest(done) {\n        self.once('firstFile', function() {\n          if (!whichGuard){\n            debug('passed control to app because first file was received');\n            whichGuard = 'receivedFirstFileOfRequest';\n          }\n          done(true);\n        });\n      },\n\n      // (3)\n      // If no files have been received by the time\n      // `maxWaitTimeBeforePassingControlToApp`ms have elapsed,\n      // go ahead and proceed.\n      function impatient(done) {\n        // Note that this is different than \"maxTimeToWaitForFirstFile\" and \"maxTimeToBuffer\"-\n        // rather, this is just the max number of ms that Skipper will wait before passing control\n        // from the body parser (i.e. calling next()).\n        //\n        timer = setTimeout(function() {\n          if (!whichGuard){\n            debug('passed control to app because %s elapsed', self.options.maxWaitTimeBeforePassingControlToApp);\n            whichGuard = 'impatient';\n          }\n          done(true);\n        }, self.options.maxWaitTimeBeforePassingControlToApp);\n      }\n\n    ],\n    function iterator(guard, done) {\n      // `guard` is one of the three functions above\n      guard(done);\n    },\n\n    // ****************************************************************\n    // Important:  Before moving on, there is one last consideration:\n    //\n    // We must also wait until all the chunks for every textparam\n    // detected before the first file has been received?\n    // This is mostly relevant for files which are extremely small\n    // compared to their preceding text parameters.\n    //\n    function finally_waitForTextParams() {\n      // Careful: No error argument allowed in this callback!\n\n      debug('waiting for any text params');\n\n      // Make sure the `impatient` timeout fires no more than once\n      clearTimeout(timer);\n\n      // Take a look at all currently known text params for this Upstream,\n      // then wait until all of them have been read.\n      var ms = 5;\n      var numTries = 0;\n      async.doUntil(\n        function setTimer(cb) {\n\n\n          // Catch-all timeout, just in case something goes awry.\n          // Should never happen, but a good failsafe to prevent holding on to\n          // control forever.  It this timeout was to fire, we should error out and\n          // cancel things.\n          numTries++;\n          if (numTries > 10) {\n            return cb(new Error(\n              'EUNFNTEX: Timed out waiting for known text parameters to finish ' +\n              'streaming their bytes into the server.'\n            ));\n          }\n\n          setTimeout(cb, ms);\n\n          // Exponential backoff\n          // (multiply ms by 2 each time, up to 500)\n          ms = ms < 500 ? ms * 2 : ms;\n\n        },\n        function checkIfAllDetectedTextParamsAreDone() {\n          return _(self.textParams).all({\n            done: true\n          });\n        },\n        function passControlToApp(err) {\n\n          // If an error occurs, run the app's error handler.\n          if (err) return self.next(err);\n\n          // At last, pass control to the app.\n          if (!self._hasPassedControlToApp) {\n            debug('Passing control to app...'.green);\n            self._hasPassedControlToApp = true;\n            self.next();\n          }\n        }\n      );\n\n    });\n\n\n\n  // Lastly, start parsing the incoming multipart upload request.\n  form.parse(this.req);\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/stringfile.js":"/**\n * Module dependencies\n */\n\nvar deep = require('dot-access')\n\t, util = require('util');\n\n\n\n\nvar STRINGFILE = {\n\t\n\twarning: {\n\t\t\n\t\tparamArrivedTooLate:\n\t\t'Unable to expose body parameter `%s` in streaming upload!\\n'+\n\t\t'Client tried to send a text parameter (%s) ' +\n\t\t'after one or more files had already been sent.\\n'+\n\t\t'Make sure you always send text params first, then your files.\\n'+\n\t\t'(In an HTML form, it\\'s as easy as making sure your text inputs are listed before your file inputs.'\n\n\t},\n\n\tparser: {\n\t\tform: {\n\t\t\tonClose: 'Form: emitted `close`'\n\t\t}\n\t}\n};\n\n\nmodule.exports = {\n\tget: function (keypath, args) {\n\t\targs = (args && args.length) ? args : [];\n\t\treturn util.format.apply(util, [deep.get(STRINGFILE, keypath)].concat(args));\n\t}\n};","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/prototype.onFile.js":"/**\n * Receive a file.\n * @param  {stream.Readable} part\t\t\t[a file from one of the fields in the multipart upload]\n */\n\nmodule.exports = function onFile(part) {\n\n  // Acquire Upstream for this field\n  // (one may or may not already exist)\n  var up = this.acquireUpstream(part.name);\n\n  // First time a file is received, emit an event\n  // and set a flag (`this._hasReceivedFirstFile`)\n  if (!this.hasReceivedFirstFile) {\n    this.emit('firstFile');\n    this._hasReceivedFirstFile = true;\n  }\n\n  // Inform Upstream about new file\n  up.writeFile(part);\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/prototype.onTextParam.js":"/**\n * Module dependencies\n */\n\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar log = require('../../standalone/logger');\nvar STRINGFILE = require('../../stringfile.js');\n\n\n\n/**\n * Receive a text parameter.\n *\n * @param  {stream.Readable} part\t\t\t[a text parameter from one of the fields in the multipart upload]\n */\n\nmodule.exports = function onTextParam(part) {\n\n  var self = this;\n  var field = part.name;\n  var value = '';\n  var decoder = new StringDecoder(this.form.encoding);\n\n  // Track fields that receive multiple param values\n  self.multifields = self.multifields || {};\n\n  // After control has been relinquished, any textparams received should be ignored\n  // since its too late to include them in `req.body` (subsequent app code is already running)\n  // So emit a warning.\n  if (this._hasPassedControlToApp) {\n    this.emit('warning', STRINGFILE.get('warning.paramArrivedTooLate', [field, field]));\n    // Redirect the part stream into the data toilet.\n    // This ensures that the stream will close properly.\n    part.on('readable', function onBytesAvailable() {\n      // Read until the buffer is dry.\n      while (null !== part.read()) { /* no-op */ }\n    });\n    return;\n  }\n\n  // Track the newly detected param\n  var textParamMetadata = {\n    done: false,\n    stream: part\n  };\n  this.textParams.push(textParamMetadata);\n\n\n  // Now receive bytes from the text param:\n\n  // TODO:\n  // Try to use pipe instead, or better yet, defer to the built-in handling\n  // w/i formidable/multiparty (as long as we're absolutely certain that doesn't\n  // trigger writing .tmp files to disk.)\n  part.on('readable', function onBytesAvailable() {\n\n    var buffer = '';\n    var chunk;\n    while (null !== (chunk = part.read())) {\n      buffer += chunk;\n    }\n\n    // New bytes available for text param:\n    if (buffer) {\n\n      // TODO: make `maxFieldsSize` directly configurable via `options`\n      self.form._fieldsSize += buffer.length;\n      if (self.form._fieldsSize > self.form.maxFieldsSize) {\n        self.form._error(new Error('maxFieldsSize exceeded, received ' + self.form._fieldsSize + ' bytes of field data'));\n        return;\n      }\n      value += decoder.write(buffer);\n      log(('Parser: Read a chunk of textparam through field `' + field + '`').grey);\n      return;\n    }\n\n    log(('Parser: Done reading textparam through field `' + field + '`').grey);\n\n\n    //\n    // Otherwise, if buffer is null, that means we've now received all of the bytes\n    // from the textparam.\n    //\n\n    // TODO: emit events instead of mutating `req` directly here.\n    // (so we don't have to pass `req` in.)\n\n    // If `req.body` already contains `field`, and this is the first duplicate value\n    // (i.e. the second value to come in for this param) track it as a \"multifield\"\n    // and build an array of param values.\n    // (We have to do this in case the original value was an array itself- we wouldn't\n    // want to push subsequent values onto THAT array, y'know?)\n    if (self.req.body[field]) {\n\n      if (self.multifields[field]) {\n        self.req.body[field].push(value);\n      } else {\n        log('`' + field + '` param already exists in req.body, converting into a \"multifield\"...');\n        self.req.body[field] = [self.req.body[field]];\n        self.multifields[field] = true;\n        self.req.body[field].push(value);\n      }\n    } else {\n      self.req.body[field] = value;\n    }\n\n    // Mark that this textParam is done streaming in data in its\n    // `textParamMetadata` object.  This is monitored and used so\n    // we know to wait for any known textParams to finish streaming\n    // before we pass control to the app.\n    textParamMetadata.done = true;\n\n  });\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/lib/Parser/prototype.acquireUpstream.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar log = require('../../standalone/logger');\nvar Upstream = require('../../standalone/Upstream');\n\n\n/**\n * Find the Upstream with `fieldName`, or\n * create and save it for the first time if necessary.\n * (Takes care of managing the collection of upstreams.)\n *\n * @param  {String} fieldName\n * @return {Upstream}\n */\n\nmodule.exports = function acquireUpstream(fieldName) {\n\n  var existingStream = _.find(this.upstreams, {\n    fieldName: fieldName\n  });\n  if (existingStream) return existingStream;\n\n\n  // If the Parser has `closed` or `_multipartyError` set to true, the request/form\n  // has already been completely parsed.  Since we don't recognize\n  // the field/Upstream, this must be a call to `req.file('foo')`,\n  // where 'foo' is not a file that is going to be coming in.\n  // So, we return a Noop stream which will immediately end itself.\n  if (this.closed || this._multipartyError) {\n    var noopUpstream = new Upstream({\n      noop: true\n    });\n    noopUpstream.fieldName = 'NOOP_'+fieldName;\n    return noopUpstream;\n  }\n\n  // Otherwise, we're good.  We should instantiate a new Upstream\n  // and assign its `fieldName`,\n  var newUpstream = new Upstream({\n    // Apply configurable timeout options\n    maxTimeToWaitForFirstFile: this.options.maxTimeToWaitForFirstFile,\n    maxTimeToBuffer: this.options.maxTimeToBuffer\n  });\n  log(('Acquiring new Upstream for field `' + fieldName + '`').grey);\n  newUpstream.fieldName = fieldName;\n  this.upstreams.push(newUpstream);\n\n\n  // If the new Upstream ever emits an 'error' event (\"READ\" error),\n  var self = this;\n  newUpstream.on('error', function(err) {\n\n    // terminate the request early (call `next(err)`)\n    if (!self._hasPassedControlToApp) {\n      self._hasPassedControlToApp = true;\n      log('Error occurred in form before control was passed.  Passing control to app error handler...'.red);\n      return self.next(err);\n    }\n\n\n    // if control has been passed, but nothing has been hooked up yet,\n    // we can't really do anything particularly helpful.\n    // We'll log a warning.\n    // (this is all to keep from throwing and crashing the app)\n    self.emit('warning', String(err));\n    return;\n\n  });\n\n\n  return newUpstream;\n\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/index.js":"module.exports = require('./Upstream');\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/Upstream.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar path = require('path');\nvar Readable = require('stream').Readable;\nvar _ = require('lodash');\nvar DefaultFileAdapter = require('skipper-disk');\nvar debug = require('debug')('skipper');\n\n\n// Extend Readable\nutil.inherits(Upstream, Readable);\n\n/**\n * Constructor\n * @param {[type]} opts [description]\n */\nfunction Upstream(opts) {\n  var self = this;\n\n  opts = opts || {};\n  _.defaults(opts, {\n    // highWaterMark: 0,\n    objectMode: true,\n\n    // The max # of ms this Upstream will wait without receiving a file\n    // before getting frustrated and emitting an error.  (This will tell\n    // any connected receivers (writestreams) that they ought to just give\n    // up themselves.  This, in turn, triggers the callback for `req.file().upload()`\n    // (no buffering is happening, so it's ok for this to be longer)\n    // This needs to be long enough to allow any policies/middleware to run.\n    // Should not need to exceed 500ms in most cases.\n    maxTimeToWaitForFirstFile: 10000,\n\n    // The max # of ms this Upstream will buffer bytes and wait to be plugged\n    // into a receiver.  highWaterMark isn't quite enough, since we want to be\n    // allow significant buffering in-memory (/utilize back-pressure whenever possible),\n    // but we also want to timeout when the really silly sort of requests come in.\n    maxTimeToBuffer: 4500\n  });\n\n  // Track fatal errors.\n  this._fatalErrors = [];\n\n  // Allow `noop` to be passed in to force this Upstream to immediately end.\n  if (opts.noop) this.isNoop = true;\n\n  // Keep track of file streams which we've emitted.\n  this._files = [];\n\n  // Keep track of timeout timers.\n  this.timeouts = {};\n\n  Readable.call(this, opts);\n\n  // Enforce the `maxTimeToWaitForFirstFile` option.\n  this.timeouts.untilFirstFileTimer = setTimeout(function() {\n    debug('maxTimeToWaitForFirstFile timer fired- as of now there are %d file uploads pending %s', self._files.length, self._files.length === 0 ? '' : '(so it\\'s fine)');\n    if (self._files.length === 0) {\n      var e = new Error();\n      e.code = 'ETIMEOUT';\n      e.message =\n        e.code + ': ' +\n        'An Upstream (`' + self.fieldName + '`) timed out waiting for file(s). ' +\n        'No files were sent after waiting ' + opts.maxTimeToWaitForFirstFile + 'ms.';\n      self.fatalIncomingError(e);\n    }\n  }, opts.maxTimeToWaitForFirstFile);\n  debug('Set up \"maxTimeToWaitForFirstFile\" timer for %dms', opts.maxTimeToWaitForFirstFile);\n\n  // Enforce the `maxTimeToBuffer` option.\n  //\n  // Note:\n  // This consideration really ought to be taken care of by the normal highWaterMark\n  // stuff.  As it is, you may not even want a `maxTimeToBuffer` in certain cases\n  // since you may be perfectly happy waiting as long as necessary; provided back-pressure\n  // is being properly applied in the receiver (we know with almost complete certainty that\n  // it's being properly applied in the sending stream because it's a request- with the caveat\n  // that it is possible to build your own fake request stream, e.g. the request interpreter in\n  // Sails, or MockReq)\n  this.timeouts.untilMaxBufferTimer = setTimeout(function() {\n    debug('maxTimeToBuffer timer fired- upstream is %s As of now there are %d file uploads', self._connected?'connected to a receiver (so we\\'re good).':'NOT CONNECTED TO A RECEIVER!!',self._files.length);\n    if (!self._connected) {\n      var e = new Error();\n      e.code = 'EMAXBUFFER';\n      e.message =\n        e.code + ': ' +\n        'An Upstream (`' + self.fieldName + '`) timed out before it was plugged into a receiver. ' +\n        'It was still unused after waiting ' + opts.maxTimeToBuffer + 'ms. ' +\n        'You can configure this timeout by changing the `maxTimeToBuffer` option.';\n      self.fatalIncomingError(e);\n    }\n  }, opts.maxTimeToBuffer);\n}\n\n\n\nUpstream.prototype._read = require('./prototype._read');\nUpstream.prototype.pipe = require('./prototype.pipe');\nUpstream.prototype.upload = require('./prototype.upload');\nUpstream.prototype.serializeFiles = require('./prototype.serializeFiles');\nUpstream.prototype.writeFile = require('./prototype.writeFile');\nUpstream.prototype.fatalIncomingError = require('./prototype.fatalIncomingError');\nUpstream.prototype.noMoreFiles = require('./prototype.noMoreFiles');\n\n\n\n\n\n\n\nmodule.exports = Upstream;\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper-disk/index.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar _ = require('lodash');\nvar fsx = require('fs-extra');\nvar r_buildDiskReceiverStream = require('./standalone/build-disk-receiver-stream');\n\n\n\n/**\n * skipper-disk\n *\n * @type {Function}\n * @param  {Object} options\n * @return {Object}\n */\n\nmodule.exports = function DiskStore(options) {\n  options = options || {};\n\n  var log = options.log || function _noOpLog() {};\n\n  var adapter = {};\n  adapter.rm = function(fd, cb) {\n    return fsx.unlink(fd, function(err) {\n      // Ignore \"doesn't exist\" errors\n      if (err && (typeof err !== 'object' || err.code !== 'ENOENT')) {\n        return cb(err);\n      } else return cb();\n    });\n  };\n\n  adapter.ls = function(dirpath, cb) {\n    return fsx.readdir(dirpath, function (err, files){\n      if (err) return cb(err);\n      files = _.reduce(_.isArray(files)?files:[], function (m, filename){\n        var fd = path.join(dirpath,filename);\n        m.push(fd);\n        return m;\n      }, []);\n      cb(null, files);\n    });\n  };\n\n  adapter.read = function(fd, cb) {\n    if (cb) {\n      return fsx.readFile(fd, cb);\n    } else {\n      return fsx.createReadStream(fd);\n    }\n  };\n\n  adapter.receive = function(opts) {\n    return r_buildDiskReceiverStream(_.defaults(opts, options), adapter);\n  };\n\n  return adapter;\n};\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper-disk/standalone/build-disk-receiver-stream.js":"/**\n * Module dependencies\n */\n\nvar WritableStream = require('stream').Writable;\nvar path = require('path');\nvar _ = require('lodash');\nvar fsx = require('fs-extra');\nvar r_buildProgressStream = require('./build-progress-stream');\nvar debug = require('debug')('skipper-disk');\nvar util = require('util');\n\n\n/**\n * A simple receiver for Skipper that writes Upstreams to\n * disk at the configured path.\n *\n * Includes a garbage-collection mechanism for failed\n * uploads.\n *\n * @param  {Object} options\n * @return {Stream.Writable}\n */\nmodule.exports = function buildDiskReceiverStream(options, adapter) {\n  options = options || {};\n  var log = options.log || function noOpLog(){};\n\n  // if maxBytes is configed in \"MB\" ended string\n  // convert it into bytes\n  if (options.maxBytes) {\n    var _maxBytesRegResult = (options.maxBytes + '').match(/(\\d+)m/i);\n    if (_maxBytesRegResult != null){\n      options.maxBytes = _maxBytesRegResult[1] * 1024 * 1024;\n    }\n  };\n\n  _.defaults(options, {\n\n    // // The default `saveAs` implements a unique filename by combining:\n    // //  • a generated UUID  (like \"4d5f444-38b4-4dc3-b9c3-74cb7fbbc932\")\n    // //  • the uploaded file's original extension (like \".jpg\")\n    // saveAs: function(__newFile, cb) {\n    //   return cb(null, UUIDGenerator.v4() + path.extname(__newFile.filename));\n    // },\n\n    // Bind a progress event handler, e.g.:\n    // function (milestone) {\n    //   milestone.id;\n    //   milestone.name;\n    //   milestone.written;\n    //   milestone.total;\n    //   milestone.percent;\n    // },\n    onProgress: undefined,\n\n    // Upload limit (in bytes)\n    // defaults to ~15MB\n    maxBytes: 15000000,\n\n    // By default, upload files to `./.tmp/uploads` (relative to cwd)\n    dirname: '.tmp/uploads'\n  });\n\n\n  var receiver__ = WritableStream({ objectMode: true });\n\n  // if onProgress handler was provided, bind an event automatically:\n  if (_.isFunction(options.onProgress)) {\n    receiver__.on('progress', options.onProgress);\n  }\n\n  // Track the progress of all file uploads that pass through this receiver\n  // through one or more attached Upstream(s).\n  receiver__._files = [];\n\n  // Keep track of the number total bytes written so that maxBytes can\n  // be enforced.\n  var totalBytesWritten = 0;\n\n\n  // This `_write` method is invoked each time a new file is received\n  // from the Readable stream (Upstream) which is pumping filestreams\n  // into this receiver.  (filename === `__newFile.filename`).\n  receiver__._write = function onFile(__newFile, encoding, done) {\n\n    // `__newFile.fd` is the file descriptor-- the unique identifier.\n    // Often represents the location where file should be written.\n\n    // If fd DOESNT have leading slash, resolve the path\n    // from process.cwd()\n    if (!__newFile.fd.match(/^\\//)) {\n      __newFile.fd = path.resolve(process.cwd(), '.tmp/uploads', __newFile.fd);\n    }\n\n    // Ensure necessary parent directories exist:\n    fsx.mkdirs(path.dirname(__newFile.fd), function(mkdirsErr) {\n      // If we get an error here, it's probably because the Node\n      // user doesn't have write permissions at the designated\n      // path.\n      if (mkdirsErr) {\n        return done(mkdirsErr);\n      }\n\n      // Error reading from the file stream\n      debug('binding error handler for incoming file in skipper-disk');\n      __newFile.on('error', function(err) {\n        debug('Read error on file '+__newFile.filename+ '::'+ util.inspect(err&&err.stack));\n        log('***** READ error on file ' + __newFile.filename, '::', err);\n      });\n\n      // Create a new write stream to write to disk\n      var outs__ = fsx.createWriteStream(__newFile.fd, encoding);\n\n      // When the file is done writing, call the callback\n      outs__.on('finish', function successfullyWroteFile() {\n        log('finished file: ' + __newFile.filename);\n        // File the file entry in the receiver with the same fd as the finished stream.\n        var file = _.find(receiver__._files, {fd: __newFile.fd});\n        if (file) {\n          // Set the byteCount of the stream to the \"total\" value of the file, which has\n          // been updated as the file was written.\n          __newFile.byteCount = file.total;\n        }\n        // If we couldn't find the file in the receiver, that's super weird, but output\n        // a notice and try to continue anyway.\n        else {\n          debug('Warning: received `finish` event for file `' + __newFile.filename + '` uploaded via field `' + __newFile.field + '`, but could not find a record of that file in the receiver.');\n          debug('Was this a zero-byte file?');\n          debug('Attempting to return the file anyway...');\n        }\n        // Indicate that a file was persisted.\n        receiver__.emit('writefile', __newFile);\n        done();\n      });\n      outs__.on('E_EXCEEDS_UPLOAD_LIMIT', function (err) {\n        done(err);\n      });\n\n      var __progress__ = r_buildProgressStream(options, __newFile, receiver__, outs__, adapter);\n\n      // Finally pipe the progress THROUGH the progress stream\n      // and out to disk.\n      __newFile\n        .pipe(__progress__)\n        .pipe(outs__);\n\n    });\n\n  };\n\n  return receiver__;\n}; // </DiskReceiver>\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper-disk/standalone/build-progress-stream.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar TransformStream = require('stream').Transform;\n\n\n\n/**\n * [exports description]\n * @param  {[type]} options    [description]\n * @param  {[type]} __newFile  [description]\n * @param  {[type]} receiver__ [description]\n * @param  {[type]} outs__     [description]\n * @return {[type]}            [description]\n */\nmodule.exports = function buildProgressStream (options, __newFile, receiver__, outs__, adapter) {\n  options = options || {};\n  var log = options.log || function noOpLog(){};\n\n  // Generate a progress stream and unique id for this file\n  // then pipe the bytes down to the outs___ stream\n  // We will pipe the incoming file stream to this, which will\n  var localID = _.uniqueId();\n  var guessedTotal = 0;\n  var writtenSoFar = 0;\n  var __progress__ = new TransformStream();\n  __progress__._transform = function(chunk, enctype, next) {\n\n    // Update the guessedTotal to make % estimate\n    // more accurate:\n    guessedTotal += chunk.length;\n    writtenSoFar += chunk.length;\n\n    // Do the actual \"writing\", which in our case will pipe\n    // the bytes to the outs___ stream that writes to disk\n    this.push(chunk);\n\n    // Emit an event that will calculate our total upload\n    // progress and determine whether we're within quota\n    this.emit('progress', {\n      id: localID,\n      fd: __newFile.fd,\n      name: __newFile.name,\n      written: writtenSoFar,\n      total: guessedTotal,\n      percent: (writtenSoFar / guessedTotal) * 100 | 0\n    });\n    next();\n  };\n\n  // This event is fired when a single file stream emits a progress event.\n  // Each time we receive a file, we must recalculate the TOTAL progress\n  // for the aggregate file upload.\n  //\n  // events emitted look like:\n  /*\n  {\n    percentage: 9.05,\n    transferred: 949624,\n    length: 10485760,\n    remaining: 9536136,\n    eta: 10,\n    runtime: 0,\n    delta: 295396,\n    speed: 949624\n  }\n  */\n  __progress__.on('progress', function singleFileProgress(milestone) {\n\n    // Lookup or create new object to track file progress\n    var currentFileProgress = _.find(receiver__._files, {\n      id: localID\n    });\n    if (currentFileProgress) {\n      currentFileProgress.written = milestone.written;\n      currentFileProgress.total = milestone.total;\n      currentFileProgress.percent = milestone.percent;\n      currentFileProgress.stream = __newFile;\n    } else {\n      currentFileProgress = {\n        id: localID,\n        fd: __newFile.fd,\n        name: __newFile.filename,\n        written: milestone.written,\n        total: milestone.total,\n        percent: milestone.percent,\n        stream: __newFile\n      };\n      receiver__._files.push(currentFileProgress);\n    }\n    ////////////////////////////////////////////////////////////////\n\n\n    // Recalculate `totalBytesWritten` so far for this receiver instance\n    // (across ALL OF ITS FILES)\n    // using the sum of all bytes written to each file in `receiver__._files`\n    var totalBytesWritten = _.reduce(receiver__._files, function(memo, status) {\n      memo += status.written;\n      return memo;\n    }, 0);\n\n    log(currentFileProgress.percent, '::', currentFileProgress.written, '/', currentFileProgress.total, '       (file #' + currentFileProgress.id + '   :: ' + /*'update#'+counter*/ '' + ')'); //receiver__._files.length+' files)');\n\n    // Emit an event on the receiver.  Someone using Skipper may listen for this to show\n    // a progress bar, for example.\n    receiver__.emit('progress', currentFileProgress);\n\n    // and then enforce its `maxBytes`.\n    if (options.maxBytes && totalBytesWritten >= options.maxBytes) {\n\n      var err = new Error();\n      err.code = 'E_EXCEEDS_UPLOAD_LIMIT';\n      err.name = 'Upload Error';\n      err.maxBytes = options.maxBytes;\n      err.written = totalBytesWritten;\n      err.message = 'Upload limit of ' + err.maxBytes + ' bytes exceeded (' + err.written + ' bytes written)';\n\n      // Stop listening for progress events\n      __progress__.removeAllListeners('progress');\n      // Unpipe the progress stream, which feeds the disk stream, so we don't keep dumping to disk\n      process.nextTick(function() {\n        __progress__.unpipe();\n      });\n      // Clean up any files we've already written\n      (function gc(err) {\n      // Garbage-collects the bytes that were already written for this file.\n      // (called when a read or write error occurs)\n        log('************** Garbage collecting file `' + __newFile.filename + '` located @ ' + __newFile.fd + '...');\n        adapter.rm(__newFile.fd, function(gcErr) {\n          if (gcErr) return outs__.emit('E_EXCEEDS_UPLOAD_LIMIT',[err].concat([gcErr]));\n          return outs__.emit('E_EXCEEDS_UPLOAD_LIMIT',err);\n        });\n      })(err);\n\n      return;\n\n      // Don't do this--it releases the underlying pipes, which confuses node when it's in the middle\n      // of a write operation.\n      // outs__.emit('error', err);\n      //\n      //\n    }\n\n  });\n\n  return __progress__;\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype._read.js":"/**\n * Module dependencies\n */\n\nvar debug = require('debug')('skipper');\n\n\n\n\nmodule.exports = function onNewDataRequested(numBytesRequested) {\n  if (numBytesRequested === 0) return;\n\n  // <todo>\n  // re: line 70 of `prototype.writeFile.js`:\n  // resume the flow of incoming part streams coming off the MPU request\n  // </todo>\n\n  // Don't really need to do anything in here for now as far as pushing data--\n  // we'll push to the receiving writestream when we're ready.\n  debug('Something is trying to read from Upstream `%s`...',this.fieldName);\n\n\n  // If we are a no-op Upstream, push `null` (ending the pipe) as soon\n  // as something tries to read us.\n  if (this.isNoop) return this.noMoreFiles();\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.pipe.js":"/**\n * Module dependencies\n */\n\nvar Readable = require('stream').Readable;\n\n\n\n/**\n * Override pipe so we know when this starts getting consumed.\n *\n * Here, we set a flag indicating that we're being read out of\n * by at least one connected receiver.\n *\n * @this {Upstream}\n * @return {Upstream} this\n * @chainable\n */\n\nmodule.exports = function pipe ( /* destination, [options] */) {\n  var self = this;\n\n  self._connected = true;\n  self._receiver = arguments[0];\n  self.once('end', function (){\n    self._emittedEnd = true;\n  });\n  self.once('error', function (){\n    self._emittedError = true;\n  });\n  return Readable.prototype.pipe.apply(self, Array.prototype.slice.call(arguments));\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.upload.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar path = require('path');\nvar util = require('util');\nvar log = require('../logger');\nvar buildOrNormalizeReceiver = require('./build-or-normalize-receiver');\nvar r_buildRenamerStream = require('./build-renamer-stream');\nvar debug = require('debug')('skipper');\nvar Writable = require('stream').Writable; // (for the leaky pipe)\n\n\n/**\n * upload()\n *\n * Convenience method to pipe to a write stream\n * and provide a traditional node callback.\n *\n * Usage:\n *\n * ```\n * .upload(receiver, cb)\n * .upload(receiver)\n * .upload(cb)\n * ```\n *\n * Alternate usage:\n * ```\n * .upload(\"filename.jpg\")\n * .upload({adapter: {receive: receiver}})\n * ```\n *\n * @param  {String|Object|stream.Writable}   opts [optional]\n * @param  {Function} _cb\n * @return {Upstream}\n * @this {Upstream}\n * @api public\n * @chainable\n */\n\nmodule.exports = function upload (opts, _cb) {\n  var self = this;\n  var USAGE = '.upload([receiver] [,callback])';\n\n  // If first parameter is the callback-function not a `receiver__`\n  if (!arguments[1] && typeof arguments[0] === 'function') {\n    _cb = opts;\n    opts = {};\n  }\n\n  // Handle first argument when it's specified as string\n  // (save it as the `saveAs` opt)\n  if (typeof opts === 'string') {\n    opts = { saveAs: opts };\n  }\n\n  // Handle `saveAs` when it's specified as string (normalize to fn)\n  if (typeof opts === 'object' && typeof opts.saveAs === 'string') {\n\n    // If the string has a leading `/`, interpret it as an absolute path.\n    // In that case, we'll infer a value for the \"dirname\" option.\n    if (!!opts.saveAs.match(/^\\//)) {\n      opts.dirname = opts.dirname || path.dirname(opts.saveAs);\n      opts.saveAs = path.basename(opts.saveAs);\n    }\n    // And in any case, we'll normalize \"saveAs\" to a function\n    var desiredFilename = opts.saveAs;\n    opts.saveAs = function (__newFile, next) {\n      next(null, desiredFilename);\n    };\n  }\n\n  // Ensure callback exists and can only be triggered once\n  var cbTriggered;\n  var cb = function (err, files){\n    if (cbTriggered) return;\n    cbTriggered = true;\n\n    if (typeof _cb === 'function') {\n      return _cb(err, files);\n    }\n    if (err) {\n      throw err; // (perhaps emit an error on the upstream instead?)\n    }\n  };\n\n  debug('.upload() called on upstream');\n\n  // If a fatal error occurred on this upstream before upload()\n  // was called, trigger the callback immediately.\n  if (self._fatalErrors.length > 0) {\n    debug('Triggering cb w/ error--upstream already has fatal error: %s', self._fatalErrors[0]);\n    // self.pipe()\n    _.each(self._files, function(file) {\n      var leaky = new Writable();\n      leaky._write = function(chunk, encoding, cb) {\n        cb();\n      };\n      file.stream.unpipe();\n      file.stream.pipe(leaky);\n    });\n    // self.unpipe();\n    // self.unpipe()\n    return cb(self._fatalErrors[0]);\n  }\n\n  // If error is emitted on this upstream, trigger the callback\n  self.once('error', function (err){\n    debug('upstream emitted error, forcing us to trigger the callback for .upload() with err: %s',err);\n    return cb(err);\n  });\n\n  // Locate, normalize, and/or build a receiver instance using the value passed in\n  // as the first argument (`receiver__`)\n  var receiver__;\n  try { receiver__ = buildOrNormalizeReceiver(opts); }\n  catch (e) {\n    return cb(e);\n  }\n\n  // For convenience, pump progress events from the receiver\n  // to this upstream.  This allows for interchangable, chainable\n  // usage, e.g. `req.file().upload(...).on('progress', ...)`\n  receiver__.on('progress', function(milestone) {\n    self.emit('progress', milestone);\n  });\n\n  // The receiver supposedly persisted a single file successfully.\n  // This should be called once per file in the upstream.\n  receiver__.on('writefile', function(fileStream) {\n    var file = _.find(self._files, {stream: fileStream});\n    file.status = 'finished';\n  });\n\n  // The receiver write stream finished successfully!\n  // This should be called when all files in the upstream\n  // have been persisted, according to the adapter.\n  receiver__.once('finish', function allFilesUploaded() {\n    log.color('grey').write('A receiver is finished writing files from Upstream `' + self.fieldName + '`.');\n    log.color('grey').write('(this doesn\\'t necessarily mean any files were actually written...)');\n    cb(null, self.serializeFiles());\n  });\n\n  // Write stream encountered a fatal error and had to quit early!\n  // (some of the files may still have been successfully written, though)\n  receiver__.on('error', function unableToUpload(err) {\n    log.color('red').write('A receiver handling Upstream `%s` encountered a write error :', self.fieldName, util.inspect(err));\n\n    // Forcibly end the incoming stream of files on this upstream\n    self.fatalIncomingError(err);\n\n    // Trigger callback\n    cb(err, self.serializeFiles());\n  });\n\n  // Build a renamer stream which will construct an `fd` for each incoming file\n  // will use the `saveAs` option, or fallback to a UUID.  Also respects `dirname`\n  // if provided.\n  //\n  // So like, the implementation here is really just a shim to make it easier to write\n  // FSAdapters by bundling reasonable file renaming functionality out of the box.\n  // Bear in mind that the receiver may change this `fd`- that's completely up to it.\n  // (for instance the disk adapter resolves paths relative to the current working\n  // directory of the Skipper process).  All a receiver needs to do is override the\n  // `fd` property on the incoming file stream itself; and of course persist the file\n  // in the revised spot.  Then when skipper calls the .upload() callback, it will\n  // transparently pass down the updated `fd` in the metadata object for that uploaded\n  // file.\n  var __renamer__ = r_buildRenamerStream({\n    saveAs: opts.saveAs,\n    dirname: opts.dirname,\n    log: log\n  });\n\n\n  // Pipe to the (Writeable) receiver.  Every time the file parser encounters a new file\n  // on this stream (i.e. a new file in the same form field), it will call Upstream's\n  // writeFile method, which will push the new file stream into Upstream's buffer.  The\n  // piping mechanism will then cause \"_write\" to be called on the Receiver, so it can\n  // handle the file in whatever way it sees fit (saving to disk, streaming to S3, etc.)\n  self.pipe(__renamer__).pipe(receiver__);\n\n  // Chainable\n  return self;\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/build-or-normalize-receiver.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar _ = require('lodash');\nvar DefaultFileAdapter = require('skipper-disk');\n\n\n\n\n/**\n * [buildOrNormalizeReceiver description]\n * @param  {[type]} opts [description]\n * @return {[type]}            [description]\n * @api private\n */\n\nmodule.exports = function buildOrNormalizeReceiver (opts) {\n\n  var receiver__;\n\n  // If a receiver instance was passed in as the first argument, use it directly\n  if (typeof opts === 'object' && opts.writable) {\n    receiver__ = opts;\n    return receiver__;\n  }\n\n  // If the first argument is undefined, treat it as an empty configuration object.\n  else if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n\n  // Now we can normalize our receiver options\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  var receiverOpts = _.cloneDeep(opts);\n\n\n  // At this point, we know we didn't receive a proper receiver instance, so we should have\n  // ended up with a configuration object. Otherwise, this is an error.\n  if (typeof receiverOpts !== 'object') {\n    var err = new Error('No valid receiver specified!');\n    e.code = 'E_USAGE';\n    err.usage = USAGE;\n    err.toString = function() {\n      return err.message + '\\nUsage: ' + err.usage + '\\n';\n    };\n    throw err;\n  }\n\n  // console.log('receiverOpts:',receiverOpts);\n\n  // Determine the file adapter to use\n  // (defaults to `DefaultFileAdapter`, defined above in the module dependencies at the top of this file)\n  var Adapter = receiverOpts.adapter || DefaultFileAdapter;\n\n  // Support Adapter as either a function\n  // or a verbatim adapter object (pass it in directly)\n  if (_.isFunction(Adapter)) {\n    Adapter = Adapter(opts);\n  }\n\n  // Finally, build a default receiver stream with the specified options\n  receiver__ = Adapter.receive(receiverOpts);\n\n  // and return it.\n  return receiver__;\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/build-renamer-stream.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar path = require('path');\nvar _ = require('lodash');\nvar TransformStream = require('stream').Transform;\nvar UUIDGenerator = require('uuid/v4');\n\n\n/**\n * [exports description]\n * @param  {Object} options    [description]\n * @return {[type]}            [description]\n */\nmodule.exports = function buildRenamerStream (options) {\n  options = options || {};\n  var log = options.log || function noOpLog(){};\n\n  var __renamer__ = new TransformStream({objectMode: true});\n  __renamer__._transform = function(__file, enctype, next) {\n\n    // Determine the unique file descriptor (`fd`).\n    // Represents the location where file should be written in the remote fs.\n    (function determineBasename (cb) {\n      // Use the `saveAs` string verbatim\n      if (_.isString(options.saveAs)) {\n        return cb(undefined, options.saveAs);\n      }\n      // Run the `saveAs` fn to determine the basename\n      else if (_.isFunction(options.saveAs)) {\n        options.saveAs(__file, function (err, fdFromUserland){\n          if (err) { return cb(err); }\n          \n          if (!_.isString(fdFromUserland)) {\n            return cb(new Error('The `saveAs` function triggered its callback, but did not send back a valid string as the 2nd argument.  Instead, got: '+util.inspect(fdFromUserland, {depth:null})+''));\n          }\n          \n          return cb(undefined, fdFromUserland);\n        });//</saveAs>\n      }\n      // The default `saveAs` implements a unique filename by combining:\n      //  • a generated UUID  (like \"4d5f444-38b4-4dc3-b9c3-74cb7fbbc932\")\n      //  • the uploaded file's original extension (like \".jpg\")\n      else {\n        return cb(undefined, UUIDGenerator()+ path.extname(__file.filename));\n      }\n    })(function (err, basename) {\n      if (err) return next(err);\n\n      __file.fd = basename;\n      if (_.isString(options.dirname)) {\n        __file.fd = path.join(options.dirname, __file.fd);\n      }\n\n      log.color('blue').write('RenamerPump:\\n• dirname => %s\\n• field => %s\\n• fd => %s', __file.dirname, __file.field,__file.fd);\n      __renamer__.push(__file);\n      next();\n    });\n  };\n\n  return __renamer__;\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.serializeFiles.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\n\n\n\n/**\n * Extract metadata for this Upstream's files.\n *\n * @return {Array}\n */\n\nmodule.exports = function serializeFiles() {\n  var self = this;\n\n  return _.reduce(self._files, function(memo, file) {\n\n    memo.push(new UploadedFileMetadata({\n      // Unique file descriptor:\n      fd: file.stream.fd,\n\n      // File size.\n      // Multiparty will attempt to set this to the value of a part's\n      // `content-length` header if such a header exists, but adapters\n      // should override this by setting `byteCount` to the size of the\n      // persisted file to ensure accuracy.\n      size: file.stream.byteCount,\n\n      // Conventional bodyParser stuff:\n      type: file.stream.headers && file.stream.headers['content-type'],\n\n      // Custom stuff:\n      filename: file.stream.filename,\n      status: file.status,\n      field: self.fieldName,\n      extra: file.stream.extra,\n\n      // Non-enumerable properties:\n      stream: file.stream\n    }));\n\n    return memo;\n  }, []);\n};\n\n\n\n\n/**\n * Simple wrapper class for making the file metadata nicer.\n *\n * @param {Object} metadata\n */\nfunction UploadedFileMetadata(metadata) {\n\n  // Make `this.orm` non-enumerable\n  Object.defineProperty(this, 'stream', { enumerable: false, writable: true });\n\n  // Merge in metadata\n  _.extend(this, metadata);\n}\n\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.writeFile.js":"/**\n * Module dependencies\n */\n\nvar Writable = require('stream').Writable; // (for the leaky pipe)\nvar async = require('async');\nvar log = require('../logger');\n\n\nmodule.exports = function writeFile (__filestream) {\n\n  var self = this;\n\n\n  var newFile = {\n    stream: __filestream,\n    status: 'bufferingOrWriting'\n  };\n\n  // Provide `__filestream.field` as alias to `__filestream.name`\n  // for consistency within the receiver (final uploaded files\n  // metadata objects have a `field` property)\n  __filestream.field = __filestream.name;\n\n  // Track incoming file stream for use in metadata sent back\n  // from `.upload()` and also in case we need to cancel it:\n  self._files.push(newFile);\n\n  // Set up error handler for the new __filestream:\n  //\n  __filestream.on('error', (function() {\n\n    // If the __filestream is not being consumed (i.e. this Upstream is not\n    // `connected` to anything), then we shouldn't allow errors on it to\n    // go unhandled (since it would throw, causing the server to crash).\n\n    // On the other hand, if this Upstream is already hooked up to one or more\n    // receivers, we're counting on them to listen for \"READ\" errors on each incoming\n    // file stream and handle them accordingly.\n    // (i.e. cancel the write and garbage collect the already-written bytes)\n\n    // So basically, in both cases, we'll sort of just catch the file\n    // READ error and... well, do nothing.\n    //\n    // (keep in mind-- an error event will still be emitted on the actual\n    // Upstream itself, but that's happening elsewhere.)\n\n\n    // Pump any remaining chunks from the __filestream into the leaky pipe\n    // TODO:\n    // I suppose it's possible this step may need to change later, but only\n    // if we want receivers to be able to continue to use the __filestreams after\n    // an error occurs (I don't see why we would..)\n    // Anyways, it's absolutely crucial that this pipe to a `leaky` Writable\n    // for everything to work.  Otherwise, responses never get sent.\n\n    //An error can be emitted on this stream more than once by underlying libraries such as multiparty\n    //Mark this event as fired already so we do not pipe the stream twice to the 'leaky' stream.\n      var hasFired = false;\n\n      return function(err) {\n          \n          if (!hasFired) {\n              var leaky = new Writable();\n              leaky._write = function(chunk, encoding, cb) {\n                  cb();\n              };\n              __filestream.unpipe();\n              __filestream.pipe(leaky);\n              log('Piping the not-yet-written bytes from incoming file `' + __filestream.filename + '` to the memory hole..');\n          }\n\n          hasFired = true;\n      };\n\n  }()));\n\n\n\n  // Pump out the new file\n  // (Upstream is a Readable stream, remember?)\n  var isBackedUp = !self.push(__filestream);\n\n  // <PERHAPS?>\n  // If the push returned false, stop pushing files for a bit\n  // (this would involve pausing the flow of incoming part streams\n  //  coming from the `on(\"part\")` signals emitted from the MPU request)\n  //\n  // Easy enough right?\n  // -BUT-\n  // Here's the challenge- the incoming MPU form closing will cause Skipper\n  // to stop listening for new files.  So we must always push __filestreams as soon\n  // as they arrive.  Not sure if changing this is even preferable...\n  // </PERHAPS?>\n\n  log.color('grey').write('Upstream: Pumping incoming file through field `%s`', self.fieldName);\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.fatalIncomingError.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar util = require('util');\nvar log = require('../logger');\nvar debug = require('debug')('skipper');\n\n\n/**\n * Called by parser implementation to signal an INCOMING fatal error\n * with one or more files being pumped by this Upstream.\n * This means that something went wrong or cancelled the entire file upload on the\n * \"source\" side (i.e. the request), and that we should invalidate the entire\n * upload.  An example of this scenario is if a user aborts the request.\n *\n * ------------------------------------------------------------------------\n * TODO:\n * Probably can deprecate this, since you almost always want to retain the\n * files that were already uploaded in this case.\n * ------------------------------------------------------------------------\n *\n * All future files on this Upstream are cancelled (stop listening to file parts)\n * and any currently-uploading files are invalidated.\n *\n * @param  {Error} err\n */\nmodule.exports = function fatalIncomingError (err) {\n\n  // Log message indicating that we are now aborting/cancelling all\n  // future, current, and previously uploaded files from this Upstream.\n  log.color('red').write('Fatal incoming error in Upstream `%s` ::   (source or user may have cancelled the request)',this.fieldName);\n  log.color('red').write(err.toString && err.toString());\n  log.color('red').write('-----------');\n  log(err.code);\n  log('%s - %s', util.inspect(err.message), util.inspect(err.name));\n  log.color('red').write('-----------');\n\n  // Emit an error event to any of file streams in this Upstream\n  // which are still being consumed.\n  //\n  // Any `receiver__`s reading this Upstream are responsible for listening to\n  // 'error' events on the incoming file readstream(s).  On receipt of such a\n  // \"READ\" error, they should cancel the upload and garbage-collect any bytes\n  // which were already written to the destination writestream(s).\n  //\n  // Receivers should, of course, ALSO listen for \"WRITE\" errors ('error' events on\n  // the outgoing writestream for each file).  The behavior is probably pretty much\n  // the same in both cases, although a receiver might, for instance, choose to retry using\n  // exponential back-off in the case of a \"WRITE\" error.  But on receiving a \"READ\" error,\n  // it should always immediately stop.  This is because such an error is usually more\n  // serious, and might even be an indication of the user trying to cancel a file upload.\n  var self = this;\n  _.each(this._files, function(file) {\n\n    // If the file has already been cancelled, return rather than emitting another error on the stream.\n    // This is because depending on the adapter, an error on the stream may result in fatalIncomingError\n    // being called again, and the receiver is only equipped to handle one fatal error (i.e. it uses\n    // .once(), which makes sense since the error is supposed to be _fatal_, after all).\n    if (file.status === 'cancelled') {\n      debug('Swallowing fatal upstream error for already-cancelled incoming file `%s` of upstream `%s`', file.stream.filename, self.fieldName);\n      return;\n    }\n\n    // If the file is finished, ignore the error.\n    if (file.status === 'finished') {\n      debug('Swallowing fatal upstream error for already-finished incoming file `%s` of upstream `%s`', file.stream.filename, self.fieldName);\n      return;\n    }\n\n    // Mark the file as cancelled\n    file.status = 'cancelled';\n\n    // Output a debug message indicating that an error occurred on the incoming file.\n    if (!self._connected){\n      debug('Forwarding fatal upstream error for unconnected (i.e. not connected to receiver) incoming file `%s` of upstream `%s`', file.stream.filename, self.fieldName);\n    } else {\n      debug('Forwarding fatal upstream error for already-connected (to receiver) incoming file `%s` of upstream `%s`', file.stream.filename, self.fieldName);\n    }\n\n    // Forward the fatal upstream error to the actual file stream so that it can re-route to the leaky pipe.\n    // Otherwise, the stream may never close, causing the response to hang.\n    file.stream.emit('error', err);\n\n  });\n\n  // Indicate the end of the Upstream (no more files coming)\n  this.noMoreFiles();\n\n\n  // Finally, emit error on this Upstream itself to cause some real trouble.\n  // If this Upstream is connected to something, this will trigger the error handler\n  // on the receiving writestream, which might contain special behavior.\n  // Otherwise, the error will be handled by the Parser, which will send a warning\n  // back up to the request, or even potentially call `next(err)`, if the parser middleware\n  // hasn't handed over control to the app yet.\n  this.emit('error', err);\n\n  // Track errors on this upstream in case its NOT connected to a receiver.\n  // This allows us to intercept attemps to .upload() to it.\n  this._fatalErrors.push(err);\n\n};\n","/home/travis/build/npmtest/node-npmtest-skipper/node_modules/skipper/standalone/Upstream/prototype.noMoreFiles.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash');\nvar log = require('../logger');\nvar debug = require('debug')('skipper');\n\n\n\n/**\n * Called by parser implementation to signal the end of the Upstream.\n * (i.e. no more files are coming)\n *\n * Anyone trying to `read()` Upstream will no longer be able to get\n * any files from it.\n *\n */\n\nmodule.exports = function noMoreFiles () {\n  // log.color('grey').write('Upstream: No more files will be sent through field `%s`', this.fieldName);\n  debug('Upstream: No more files will be sent through field `%s`- clearing timeouts...', this.fieldName);\n  this.push(null);\n\n  // Clear all timeouts\n  _.each(this.timeouts, function(timer, key) {\n    clearTimeout(timer);\n  });\n};\n"}